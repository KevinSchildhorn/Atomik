"use strict";(self.webpackChunkatomik_docs=self.webpackChunkatomik_docs||[]).push([[312],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>u});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),p=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},y=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),c=p(n),y=a,u=c["".concat(l,".").concat(y)]||c[y]||d[y]||i;return n?o.createElement(u,r(r({ref:t},m),{},{components:n})):o.createElement(u,r({ref:t},m))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=y;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:a,r[1]=s;for(var p=2;p<i;p++)r[p]=n[p];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}y.displayName="MDXCreateElement"},2659:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var o=n(7462),a=(n(7294),n(3905));const i={sidebar_position:3},r="Design System",s={unversionedId:"core-concepts/design-systems",id:"core-concepts/design-systems",title:"Design System",description:"A design system is a collection of reusable components, guided by clear standards, that can be assembled together to build any number of applications.",source:"@site/docs/core-concepts/design-systems.md",sourceDirName:"core-concepts",slug:"/core-concepts/design-systems",permalink:"/Atomik/docs/core-concepts/design-systems",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/core-concepts/design-systems.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Molecules and Beyond",permalink:"/Atomik/docs/core-concepts/molecules"},next:{title:"Colors",permalink:"/Atomik/docs/core-concepts/colors"}},l={},p=[{value:"Defining a Design System",id:"defining-a-design-system",level:2},{value:"Preset Design Systems",id:"preset-design-systems",level:3},{value:"Design System Elements",id:"design-system-elements",level:2},{value:"ColorSet",id:"colorset",level:3},{value:"TypographySet",id:"typographyset",level:3},{value:"FontFamily",id:"fontfamily",level:3},{value:"Android",id:"android",level:4},{value:"iOS",id:"ios",level:4}],m={toc:p},c="wrapper";function d(e){let{components:t,...i}=e;return(0,a.kt)(c,(0,o.Z)({},m,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"design-system"},"Design System"),(0,a.kt)("p",null,"A design system is a collection of reusable components, guided by clear standards, that can be assembled together to build any number of applications.\n(This collection of reusable components can also be referred to as a Pattern Library). The design system for developer purposes consists of five major sections:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Layout")," - The spacing and organization of components"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Typography")," - The font and styling of text"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Color")," - The colors used in the design"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Components")," - UI elements used in the design"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Iconography")," - logos and images used in the design")),(0,a.kt)("h2",{id:"defining-a-design-system"},"Defining a Design System"),(0,a.kt)("p",null,"An Atomik Design System currently handles three parts of the design System: color, typography and components."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"DesignSystem")," takes in four variables, a ",(0,a.kt)("inlineCode",{parentName:"p"},"ColorSet"),", a ",(0,a.kt)("inlineCode",{parentName:"p"},"TypographySet"),", a map of ",(0,a.kt)("inlineCode",{parentName:"p"},"Atoms"),", and a ",(0,a.kt)("inlineCode",{parentName:"p"},"fontFamily")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"open class DesignSystem(\n    open val colorSet: ColorSet,\n    open val typographySet: TypographySet,\n    open val atoms: Map<String, Atom>,\n    open var fontFamily: AtomikFontFamily? = null\n)\n")),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"The font family is a temporary addition and can be removed once common fonts are added")),(0,a.kt)("h3",{id:"preset-design-systems"},"Preset Design Systems"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"DesignSystem")," should encompass all of the elements of your other Atomik classes. The ",(0,a.kt)("inlineCode",{parentName:"p"},"DesignSystem")," takes in interfaces for colors and typography, and can be easily customized. Additionally there are some existing presets that are recommended based on what you need:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"DefaultDesignSystem")," - A default implementation of a ",(0,a.kt)("inlineCode",{parentName:"li"},"DesignSystem"),", contains useful data for most cases"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"PlatformDesignSystem")," - Based on the Platforms structure, meshes well with structures like compose Typograhy."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CustomDesignSystem"),"  - A customizeable ",(0,a.kt)("inlineCode",{parentName:"li"},"DesignSystem"),", supports a completely unique pattern rather than using standards like ",(0,a.kt)("inlineCode",{parentName:"li"},"h1")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"body")," for typography")),(0,a.kt)("h2",{id:"design-system-elements"},"Design System Elements"),(0,a.kt)("h3",{id:"colorset"},"ColorSet"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Color Set",src:n(8633).Z,width:"1444",height:"1194"})),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"ColorSet")," is an interface that is meant to contain all colors in your project. Most ColorSets are classes that contain a Map of Colors and a fallback color in case it's not found."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"public interface ColorSet {\n    public val fallbackColor: AtomikColor\n    public fun getColor(name: String): AtomikColor\n}\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"ColorSets")," are made up of various ",(0,a.kt)("a",{parentName:"p",href:"/Atomik/docs/core-concepts/colors"},"AtomikColor")),(0,a.kt)("p",null,"They can be implemented, however there's also a ",(0,a.kt)("inlineCode",{parentName:"p"},"DefaultColorSet")," for a standard set. There is also a ",(0,a.kt)("inlineCode",{parentName:"p"},"CustomColorSet")," that can be used for more granularity."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"val colorSet = DefaultColorSet(\n    primary = AtomikColor(0xFFFFA500),\n    secondary = AtomikColor(0xFFFFD383),\n    background = AtomikColor(0xFFFFFFFF),\n    surface = AtomikColor(0xFFFFFFFF),\n    error = AtomikColor(0xFFFF0000),\n\n    primaryText = AtomikColor(0xFF402900),\n    secondaryText = AtomikColor(0xFFFFA500),\n    backgroundText = AtomikColor(0xFF25231F),\n    surfaceText = AtomikColor(0xFFFFA500),\n    errorText = AtomikColor(0xFF9E1F1F),\n)\n")),(0,a.kt)("h3",{id:"typographyset"},"TypographySet"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Typography Set",src:n(6979).Z,width:"1556",height:"1592"})),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"TypographySet")," is an interface that is meant to contain all typography data in your project. It is an interface that can be implemented, however there's also a ",(0,a.kt)("inlineCode",{parentName:"p"},"DefaultTypographySet")," for a standard set. There is also a ",(0,a.kt)("inlineCode",{parentName:"p"},"CustomTypographySet")," that can be used for granularity."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"TypographySets")," are made up of various ",(0,a.kt)("inlineCode",{parentName:"p"},"AtomikTypography"),", which are referenced by a ",(0,a.kt)("a",{parentName:"p",href:"./typography"},"TypographyType"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"val typographySet = DefaultTypographySet(\n    h1 = AtomikTypography(size = 96),\n    h2 = AtomikTypography(size = 60),\n    h3 = AtomikTypography(size = 48),\n    h4 = AtomikTypography(size = 34),\n    subtitle = AtomikTypography(size = 16),\n    button = AtomikTypography(weight = AtomikTypographyWeight.BOLD, size = 14),\n    body = AtomikTypography(size = 16),\n    caption = AtomikTypography(weight = AtomikTypographyWeight.BOLD, size = 14),\n)\n")),(0,a.kt)("h3",{id:"fontfamily"},"FontFamily"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"AtomikFontFamily")," is an expect/actual class for platform specific fonts. When initializing the Design System it's easier to set it to null and pass in the ",(0,a.kt)("inlineCode",{parentName:"p"},"FontFamily")," later, when the app is started"),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"The font family is a temporary addition and can be removed once common fonts are added")),(0,a.kt)("h4",{id:"android"},"Android"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"val fontFamily = FontFamily(\n    Font(R.font.quicksand_regular),\n    Font(R.font.quicksand_bold, FontWeight.Bold),\n    Font(R.font.quicksand_light, FontWeight.Light),\n    Font(R.font.quicksand_medium, FontWeight.Medium),\n    Font(R.font.quicksand_semibold, FontWeight.SemiBold),\n)\ndesignSystem.fontFamily = AtomikFontFamily(fontFamily)\n")),(0,a.kt)("h4",{id:"ios"},"iOS"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-swift"},'let fontFamily = [\n    .bold: UIFont(name: "Quicksand-Bold", size: 12)!,\n    .light: UIFont(name: "Quicksand-Light", size: 12)!,\n    .medium: UIFont(name: "Quicksand-Medium", size: 12)!,\n    .normal: UIFont(name: "Quicksand-Regular", size: 12)!,\n    .semibold: UIFont(name: "Quicksand-SemiBold", size: 12)!\n]\nUIDesignKt.designSystem.fontFamily = AtomikAtomikFontFamily(uiFonts: fontFamily)\n')))}d.isMDXComponent=!0},8633:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/colorset-8d727d848097932816bba431a0fec4d5.png"},6979:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/typographyset-2409b258c0d3feb6c91bf8acfe7e8222.png"}}]);